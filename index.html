<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Interaction Lab (No Super-Hands)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- AR.js for A-Frame (marker-based AR) -->
  <!-- Use NFT-enabled build so <a-nft> works. If this CDN is blocked, replace with a suitable NFT build. -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

  <style>
    body { margin:0; overflow:hidden; }
    .hud {
      position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%);
      display: grid; grid-template-columns: repeat(5, auto); gap: 8px;
      font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10; pointer-events: none;
    }
    .hud.hidden { display: none; }
    .hud button {
      pointer-events: auto;
      padding: 10px 12px; border: 0; border-radius: 10px;
      background: rgba(255,255,255,.9);
    }
    .status {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.6); color: #fff; padding: 6px 10px; border-radius: 8px;
      font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; z-index: 20;
      pointer-events: none;
    }
    .unlock-hint {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8); color: #FF6B6B; padding: 20px 30px; border-radius: 12px;
      font: 700 32px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; z-index: 15;
      pointer-events: none; display: none; text-align: center;
    }
    .unlock-hint.visible { display: block; }
    .story-text {
      position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.85); color: #4CC3D9; padding: 15px 25px; border-radius: 10px;
      font: 600 18px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; z-index: 15;
      pointer-events: none; display: none; text-align: center; max-width: 80%;
    }
    .story-text.visible { display: block; }
  </style>

  <script>
  // ---------- Utilities ----------
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // ---------- Pivot recentre (center + sit on ground) ----------
  AFRAME.registerComponent('recenter-pivot', {
    schema: { ground: {default: true} },
    init(){
      this.el.addEventListener('model-loaded', () => {
        const mesh = this.el.getObject3D('mesh');
        if (!mesh) return;
        const box = new THREE.Box3().setFromObject(mesh);
        const center = box.getCenter(new THREE.Vector3());
        mesh.position.sub(center); // move geometry so pivot is at center
        if (this.data.ground) {
          box.setFromObject(mesh);
          mesh.position.y -= box.min.y; // drop so wheels touch the plane
        }
      });
    }
  });

  // ---------- 1) Tap / doubletap / longpress ----------
  AFRAME.registerComponent('tap-gestures', {
    schema: {longMs:{default:500}},
    init () {
      let lastTap = 0, pressTimer = null, down = false;
      this.el.addEventListener('mousedown', () => {
        down = true;
        const now = performance.now();
        if (now - lastTap < 300) this.el.emit('doubletap');
        lastTap = now;
        pressTimer = setTimeout(() => { if (down) this.el.emit('longpress'); }, this.data.longMs);
      });
      this.el.addEventListener('mouseup', () => {
        down = false;
        clearTimeout(pressTimer);
        this.el.emit('tap');
      });
      this.el.addEventListener('touchstart', e => e.preventDefault(), {passive:false});
    }
  });

  // ---------- 2) Drag on a plane (marker plane) ----------
  // Drag with mouse/touch by intersecting an invisible plane and moving the entity to that point.
  AFRAME.registerComponent('drag-on-plane', {
    schema: { plane: {type: 'selector'}, yOffset: {default: 0.25}, radius: {default: 0.6} },
    init () {
      this.dragging = false;
      this.scene = this.el.sceneEl;
      this.rayEl = document.querySelector('#ray'); // scene cursor ray
      // listen on element
      this.el.addEventListener('mousedown', () => this.dragging = true);
      window.addEventListener('mouseup',   () => this.dragging = false);
      window.addEventListener('touchend',  () => this.dragging = false);
      // move
      this.scene.addEventListener('mousemove', (e)=> this.updateDrag());
      this.scene.addEventListener('touchmove', (e)=> this.updateDrag());
    },
    updateDrag () {
      if (!this.dragging) return;
      if (!this.data.plane) return;
      const raycaster = this.rayEl.getObject3D('raycaster');
      if (!raycaster) return;
      const planeMesh = this.data.plane.getObject3D('mesh');
      if (!planeMesh) return;

      // Build a THREE.Plane from the plane entity (its world transform).
      planeMesh.updateMatrixWorld();
      const normal = new THREE.Vector3(0,1,0).applyQuaternion(planeMesh.getWorldQuaternion(new THREE.Quaternion()));
      const point  = planeMesh.getWorldPosition(new THREE.Vector3());
      const plane  = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, point);

      const ray = raycaster.ray; // world-space ray from cursor
      const hit = new THREE.Vector3();
      if (ray.intersectPlane(plane, hit)) {
        // constrain to radius on XZ around marker center
        const local = this.el.parentEl.object3D.worldToLocal(hit.clone());
        const r = Math.hypot(local.x, local.z);
        const maxR = this.data.radius;
        if (r > maxR){
          const k = maxR / r;
          local.x *= k; local.z *= k;
        }
        this.el.setAttribute('position', `${local.x} ${this.data.yOffset} ${local.z}`);
      }
    }
  });

  // ---------- 3) Pinch to scale ----------
  AFRAME.registerComponent('pinch-scale', {
    schema: {min:{default:0.2}, max:{default:3}},
    init(){
      this.active = false; this.startD = 0; this.startScale = null;
      const onStart = (e) => {
        if (e.touches && e.touches.length === 2){
          this.active = true;
          this.startD = this.dist(e.touches[0], e.touches[1]);
          this.startScale = Object.assign({}, this.el.getAttribute('scale'));
        }
      };
      const onMove = (e) => {
        if (!this.active || !e.touches || e.touches.length < 2) return;
        const d = this.dist(e.touches[0], e.touches[1]);
        const mult = d / this.startD;
        const ns = {
          x: clamp(this.startScale.x * mult, this.data.min, this.data.max),
          y: clamp(this.startScale.y * mult, this.data.min, this.data.max),
          z: clamp(this.startScale.z * mult, this.data.min, this.data.max),
        };
        this.el.setAttribute('scale', ns);
      };
      const onEnd = () => this.active = false;
      window.addEventListener('touchstart', onStart, {passive:false});
      window.addEventListener('touchmove',  onMove,  {passive:false});
      window.addEventListener('touchend',   onEnd);
      window.addEventListener('touchcancel',onEnd);
    },
    dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
  });

  // ---------- 4) Twist to rotate (two-finger) ----------
  AFRAME.registerComponent('twist-rotate', {
    schema:{degPerRad:{default:57.2958}}, // 180/Ï€
    init(){
      this.active = false; this.startA = 0; this.startRotY = 0;
      const angle = (a,b)=> Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX);
      const onStart = (e)=>{
        if (e.touches && e.touches.length === 2){
          this.active = true;
          this.startA = angle(e.touches[0], e.touches[1]);
          this.startRotY = this.el.getAttribute('rotation').y;
        }
      };
      const onMove = (e)=>{
        if (!this.active || !e.touches || e.touches.length < 2) return;
        const a = angle(e.touches[0], e.touches[1]);
        const delta = (a - this.startA) * this.data.degPerRad;
        const r = this.el.getAttribute('rotation');
        this.el.setAttribute('rotation', {x:r.x, y:this.startRotY + delta, z:r.z});
      };
      const onEnd = ()=> this.active = false;
      window.addEventListener('touchstart', onStart, {passive:false});
      window.addEventListener('touchmove',  onMove,  {passive:false});
      window.addEventListener('touchend',   onEnd);
      window.addEventListener('touchcancel',onEnd);
    }
  });

  // ---------- 5) Spin toggler + random color (hooked to taps) ----------
  AFRAME.registerComponent('spin-toggle', {
    schema:{speed:{default:4000}},
    init(){
      this.spinning = false;
      this.el.addEventListener('toggle-spin', ()=> {
        this.spinning = !this.spinning;
        if (this.spinning) {
          this.el.setAttribute('animation__spin',
            `property: rotation; to: 0 360 0; loop: true; dur: ${this.data.speed}`);
        } else {
          this.el.removeAttribute('animation__spin');
        }
      });
      this.el.addEventListener('random-color', ()=> {
        const colors = ['#4CC3D9','#FFC65D','#7BC8A4','#EF2D5E','#FFFFFF'];
        const c = colors[Math.floor(Math.random()*colors.length)];
        this.el.setAttribute('material','color',c);
      });
    }
  });
  </script>
</head>
<body>
  <!-- HUD -->
  <div class="hud" id="hud">
    <button id="btn-rot-l">âŸ²</button>
    <button id="btn-rot-r">âŸ³</button>
    <button id="btn-scale--">âˆ’</button>
    <button id="btn-scale-+">ï¼‹</button>
    <button id="btn-color">ðŸŽ¨</button>
  </div>
  <div class="unlock-hint" id="unlockHint"></div>
  <div class="story-text" id="storyText"></div>


  <a-scene
    embedded
    renderer="colorManagement: true; physicallyCorrectLights: true"
    xr-mode-ui="enabled: false"
    arjs="sourceType: webcam; detectionMode: mono; debugUIEnabled: false">

    <!-- Cursor ray for mouse/touch (A-Frame builds a raycaster object3D for us) -->
    <a-entity id="ray" cursor="rayOrigin: mouse" raycaster="objects: .raytarget"></a-entity>

    <!-- Lights -->
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="0 1 1"></a-entity>

    <!-- NFT Markers mapped to your images/models -->
    <!-- School image -> Girl model -->
    <a-nft type="nft" url="./markers/School" smooth="true" changeMatrixMode="modelViewMatrix" id="marker-school">
      <a-plane id="dragplane-school" class="raytarget"
               position="0 0 0" rotation="-90 0 0" width="2" height="2"
               material="color: #000; opacity: 0; transparent: true"></a-plane>

      <a-entity id="girlModel" class="raytarget"
        gltf-model="url(3D/Girl.glb)" 
        position="100 50 -100" rotation="-90 0 0" scale="70 70 70"
        animation__spin="property: rotation; from: -90 0 0; to: -90 0 360; loop: true; dur: 11000; easing: linear"
        visible="false"
        tap-gestures spin-toggle
        drag-on-plane="plane: #dragplane-school; yOffset: 0.15; radius: 0.6"
        pinch-scale twist-rotate>
      </a-entity>

      <a-cylinder radius="0.01" height="0.001" color="#888"></a-cylinder>
    </a-nft>

    <!-- Class image -> Book model -->
    <a-nft type="nft" url="./markers/Class" smooth="true" changeMatrixMode="modelViewMatrix" id="marker-class">
      <a-plane id="dragplane-class" class="raytarget"
               position="0 0 0" rotation="-90 0 0" width="2" height="2"
               material="color: #000; opacity: 0; transparent: true"></a-plane>

      <a-entity id="bookModel" class="raytarget"
        gltf-model="url(3D/Book.glb)"
        position="100 50 -100" rotation="0 0 0" scale="0.15 0.15 0.15"
          animation__spin="property: rotation; from: 0 0 0; to: 0 0 360; loop: true; dur: 7000; easing: linear"
                visible="false"
                tap-gestures spin-toggle
                drag-on-plane="plane: #dragplane-class; yOffset: 0.1; radius: 0.6"
                pinch-scale twist-rotate>
      </a-entity>

      <a-cylinder radius="0.01" height="0.001" color="#888"></a-cylinder>
    </a-nft>

    <!-- Gym image -> Ball model -->
    <a-nft type="nft" url="./markers/Gym" smooth="true" changeMatrixMode="modelViewMatrix" id="marker-gym">
      <a-plane id="dragplane-gym" class="raytarget"
               position="0 0 0" rotation="-90 0 0" width="2" height="2"
               material="color: #000; opacity: 0; transparent: true"></a-plane>

      <a-entity id="ballModel" class="raytarget"
        gltf-model="url(3D/Ball.glb)"
        position="100 50 -100" rotation="0 0 0" scale="12 12 12"
          animation__spin="property: rotation; from: 0 0 0; to: 0 0 360; loop: true; dur: 10000; easing: linear"
                visible="false"
                tap-gestures spin-toggle
                drag-on-plane="plane: #dragplane-gym; yOffset: 0.18; radius: 0.6"
                pinch-scale twist-rotate>
      </a-entity>

      <a-cylinder radius="0.01" height="0.001" color="#888"></a-cylinder>
    </a-nft>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // Runtime check: ensure a-nft support is available
    (function(){
      const statusEl = document.getElementById('status');
      function setStatus(t){ if (statusEl) statusEl.textContent = t; }
      // Wait for A-Frame to initialize
      window.addEventListener('load', ()=>{
        setTimeout(()=>{
          const hasANft = !!(window.AFRAME && (AFRAME.components && AFRAME.components['nft'] || customElements.get && customElements.get('a-nft')));
          if (!hasANft){
            console.error('NFT support (a-nft) not detected.');
            setStatus('Error: NFT support not loaded. See console.');
            // Also show a visible hint overlay
            const hint = document.createElement('div');
            hint.style.position = 'fixed'; hint.style.bottom='14px'; hint.style.left='50%'; hint.style.transform='translateX(-50%)';
            hint.style.background='rgba(255,60,60,0.95)'; hint.style.color='#fff'; hint.style.padding='8px 12px'; hint.style.borderRadius='8px';
            hint.style.zIndex='40'; hint.textContent = 'NFT support missing â€” try the NFT-enabled AR.js build';
            document.body.appendChild(hint);
          } else {
            console.log('NFT support appears available.');
          }
        }, 800);
      });
    })();

    // Debug: Log model loading
    window.addEventListener('load', () => {
      setTimeout(() => {
        const girl = document.getElementById('girlModel');
        const book = document.getElementById('bookModel');
        const ball = document.getElementById('ballModel');
        
        console.log('=== MODEL LOADING DEBUG ===');
        console.log('Girl model element:', girl);
        console.log('Book model element:', book);
        console.log('Ball model element:', ball);
        
        [
          { name: 'Girl', el: girl },
          { name: 'Book', el: book },
          { name: 'Ball', el: ball }
        ].forEach(({name, el}) => {
          if (el) {
            const gltf = el.getAttribute('gltf-model');
            console.log(`${name}: gltf-model = ${gltf}`);
            console.log(`${name}: initial visible = ${el.getAttribute('visible')}`);
            el.addEventListener('model-loaded', () => {
              console.log(`âœ“ ${name} model LOADED successfully`);
            });
            el.addEventListener('error', (e) => {
              console.error(`âœ— ${name} model FAILED to load:`, e);
            });
          } else {
            console.error(`âœ— ${name} model element NOT FOUND in DOM`);
          }
        });
        
        console.log('=== MARKER DEBUG ===');
        const markerSchool = document.getElementById('marker-school');
        const markerClass = document.getElementById('marker-class');
        const markerGym = document.getElementById('marker-gym');
        
        console.log('School marker:', markerSchool, 'NFT URL:', markerSchool?.getAttribute('url'));
        console.log('Class marker:', markerClass, 'NFT URL:', markerClass?.getAttribute('url'));
        console.log('Gym marker:', markerGym, 'NFT URL:', markerGym?.getAttribute('url'));
      }, 1000);
    });
  </script>
  <script>
    // HUD and model controls work on the currently visible model (if any)
    const hud    = document.getElementById('hud');
    const girl   = document.getElementById('girlModel');
    const book   = document.getElementById('bookModel');
    const ball   = document.getElementById('ballModel');
    const unlockHint = document.getElementById('unlockHint');
    const storyText = document.getElementById('storyText');

    const markerSchool = document.getElementById('marker-school');
    const markerClass  = document.getElementById('marker-class');
    const markerGym    = document.getElementById('marker-gym');

    // Track scanned markers for sequential unlocking
    let scannedMarkers = new Set();
    const markerSequence = ['School', 'Class', 'Gym'];
    
    // Multi-scenario interaction state
    let interactionMode = 'discovery'; // discovery, synergy, celebration
    let girlTapCount = 0;
    let bookTapCount = 0;
    let ballTapCount = 0;
    let lastTappedModel = null;

    function getActiveModel(){
      if (girl && girl.getAttribute('visible')) return girl;
      if (book  && book.getAttribute('visible'))  return book;
      if (ball  && ball.getAttribute('visible'))  return ball;
      return null;
    }

    // Check if a marker can be unlocked based on sequence
    function canUnlockMarker(markerName) {
      const index = markerSequence.indexOf(markerName);
      if (index === 0) return true; // First marker always unlocked
      // Check if all previous markers have been scanned
      for (let i = 0; i < index; i++) {
        if (!scannedMarkers.has(markerSequence[i])) {
          return false;
        }
      }
      return true;
    }

    // Show story text helper
    function showStory(text, duration = 4000) {
      storyText.textContent = text;
      storyText.classList.add('visible');
      setTimeout(() => storyText.classList.remove('visible'), duration);
    }

    // Multi-scenario interaction: Cross-object effects
    function handleCrossObjectInteraction(tappedModel) {
      const visibleModels = [girl, book, ball].filter(m => m && m.getAttribute('visible') === 'true');
      
      // Scenario 1: Discovery Mode (only 1 object visible)
      if (visibleModels.length === 1) {
        if (interactionMode !== 'discovery') {
          interactionMode = 'discovery';
          showStory('ðŸ” Discovery Mode: Explore the girl and find what she seeks...');
        }
      }
      
      // Scenario 2: Synergy Mode (2 objects visible - Girl + Book)
      else if (visibleModels.length === 2 && interactionMode !== 'synergy') {
        interactionMode = 'synergy';
        showStory('ðŸ“š Synergy Mode: The girl found her book! Tap them both to create magic!', 5000);
        
        // Cross-object effect: When girl is tapped, book grows
        if (tappedModel === girl && book.getAttribute('visible') === 'true') {
          const bookScale = book.getAttribute('scale');
          book.setAttribute('scale', {
            x: Math.min(bookScale.x * 1.2, 0.25),
            y: Math.min(bookScale.y * 1.2, 0.25),
            z: Math.min(bookScale.z * 1.2, 0.25)
          });
          showStory('âœ¨ The book glows as the girl approaches!', 2000);
        }
        
        // Cross-object effect: When book is tapped, girl spins faster
        if (tappedModel === book && girl.getAttribute('visible') === 'true') {
          girl.setAttribute('animation__spin', 
            'property: rotation; from: -90 0 0; to: -90 0 360; loop: true; dur: 5000; easing: linear');
          showStory('ðŸ’« The girl dances with joy!', 2000);
        }
      }
      
      // Scenario 3: Celebration Mode (all 3 objects visible)
      else if (visibleModels.length === 3 && interactionMode !== 'celebration') {
        interactionMode = 'celebration';
        showStory('ðŸŽ‰ Celebration Mode: All together! Tap any to create harmony!', 5000);
        
        // Synchronized celebration effect
        setTimeout(() => {
          if (girl.getAttribute('visible') === 'true') {
            girl.setAttribute('animation__bounce', 
              'property: position; from: 100 50 -100; to: 100 80 -100; dir: alternate; loop: 3; dur: 1000; easing: easeInOutQuad');
          }
          if (book.getAttribute('visible') === 'true') {
            book.setAttribute('animation__bounce', 
              'property: position; from: 100 50 -100; to: 100 80 -100; dir: alternate; loop: 3; dur: 1000; easing: easeInOutQuad');
          }
          if (ball.getAttribute('visible') === 'true') {
            ball.setAttribute('animation__bounce', 
              'property: position; from: 100 50 -100; to: 100 80 -100; dir: alternate; loop: 3; dur: 1000; easing: easeInOutQuad');
          }
        }, 500);
      }
      
      // Combo detection: Tap girl then book then ball in sequence
      if (lastTappedModel === girl && tappedModel === book) {
        showStory('ðŸ”— Combo: Girl â†’ Book! Keep going!', 2000);
      } else if (lastTappedModel === book && tappedModel === ball) {
        showStory('ðŸŒŸ PERFECT COMBO! Girl â†’ Book â†’ Ball achieved!', 3000);
        // Grand finale effect
        [girl, book, ball].forEach(m => {
          if (m && m.getAttribute('visible') === 'true') {
            m.emit('random-color');
          }
        });
      }
      
      lastTappedModel = tappedModel;
    }

    // Buttons
    document.getElementById('btn-rot-l').addEventListener('click', () => nudgeRot(-15));
    document.getElementById('btn-rot-r').addEventListener('click', () => nudgeRot( 15));
    function nudgeRot(delta){
      const m = getActiveModel(); if (!m) return;
      const r = m.getAttribute('rotation') || {x:0,y:0,z:0};
      m.setAttribute('rotation', {x:r.x, y:r.y + delta, z:r.z});
    }

    document.getElementById('btn-scale--').addEventListener('click', () => nudgeScale(0.9));
    document.getElementById('btn-scale-+').addEventListener('click', () => nudgeScale(1.1));
    function nudgeScale(mult){
      const m = getActiveModel(); if (!m) return;
      const s = m.getAttribute('scale') || {x:1,y:1,z:1};
      m.setAttribute('scale', {
        x: clamp(s.x * mult, 0.2, 3),
        y: clamp(s.y * mult, 0.2, 3),
        z: clamp(s.z * mult, 0.2, 3)
      });
    }

    document.getElementById('btn-color').addEventListener('click', () => {
      const m = getActiveModel(); if (!m) return; m.emit('random-color');
    });

    // Gesture hooks for each model (tap/doubletap/longpress)
    [girl, book, ball].forEach(m => {
      if (!m) return;
      
      m.addEventListener('tap', () => {
        m.emit('toggle-spin');
        handleCrossObjectInteraction(m);
      });
      
      m.addEventListener('doubletap', () => {
        m.emit('random-color');
        
        // Count taps for narrative progression
        if (m === girl) girlTapCount++;
        else if (m === book) bookTapCount++;
        else if (m === ball) ballTapCount++;
        
        // Easter egg: If all objects tapped twice
        if (girlTapCount >= 2 && bookTapCount >= 2 && ballTapCount >= 2) {
          showStory('ðŸŽŠ SECRET UNLOCKED: You discovered the rainbow harmony!', 4000);
          girlTapCount = bookTapCount = ballTapCount = 0;
        }
      });
      
      m.addEventListener('longpress', () => hud.classList.toggle('hidden'));
    });

    // Helper to set status text
    const statusEl = document.getElementById('status');
    function setStatus(text){ if (!statusEl) return; statusEl.textContent = text; }

    // Marker found/lost handlers: show/hide corresponding model and update status
    markerSchool.addEventListener('markerFound', () => {
      console.log('âœ“ School marker FOUND - attempting to show Girl model');
      console.log('  Girl element:', girl);
      if (girl) {
        scannedMarkers.add('School');
        girl.setAttribute('visible','true');
        showStory('ðŸ‘§ A girl appears, seeking knowledge...', 3000);
        console.log('  Girl visible set to:', girl.getAttribute('visible'));
      } else {
        console.error('  ERROR: Girl element is null!');
      }
    });
    markerSchool.addEventListener('markerLost', () => {
      console.log('âœ— School marker LOST - hiding Girl model');
      if (girl) {
        girl.setAttribute('visible','false');
      }
    });

    markerClass.addEventListener('markerFound', () => {
      if (!canUnlockMarker('Class')) {
        console.log('âš  Class marker found but locked - scan Girl first');
        unlockHint.textContent = 'Scan the Girl first!';
        unlockHint.classList.add('visible');
        return;
      }
      console.log('âœ“ Class marker FOUND - attempting to show Book model');
      console.log('  Book element:', book);
      unlockHint.classList.remove('visible');
      if (book) {
        scannedMarkers.add('Class');
        book.setAttribute('visible','true');
        showStory('ðŸ“– The book of wisdom appears! Tap both to unlock synergy!', 4000);
        handleCrossObjectInteraction(book);
        console.log('  Book visible set to:', book.getAttribute('visible'));
      } else {
        console.error('  ERROR: Book element is null!');
      }
    });
    markerClass.addEventListener('markerLost', () => {
      console.log('âœ— Class marker LOST - hiding Book model');
      unlockHint.classList.remove('visible');
      if (book) {
        book.setAttribute('visible','false');
      }
    });

    markerGym.addEventListener('markerFound', () => {
      if (!canUnlockMarker('Gym')) {
        console.log('âš  Gym marker found but locked - scan Girl and Book first');
        unlockHint.textContent = 'Scan Girl & Book first!';
        unlockHint.classList.add('visible');
        return;
      }
      console.log('âœ“ Gym marker FOUND - attempting to show Ball model');
      console.log('  Ball element:', ball);
      unlockHint.classList.remove('visible');
      if (ball) {
        scannedMarkers.add('Gym');
        ball.setAttribute('visible','true');
        showStory('âš½ The ball of play joins! All united - tap for harmony!', 4000);
        handleCrossObjectInteraction(ball);
        console.log('  Ball visible set to:', ball.getAttribute('visible'));
      } else {
        console.error('  ERROR: Ball element is null!');
      }
    });
    markerGym.addEventListener('markerLost', () => {
      console.log('âœ— Gym marker LOST - hiding Ball model');
      unlockHint.classList.remove('visible');
      if (ball) {
        ball.setAttribute('visible','false');
      }
    });
  </script>
</body>
</html>
